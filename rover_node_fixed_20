#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from pymavlink import mavutil
import time

class RoverControl(Node):
    def __init__(self):
        super().__init__('rover_control')
        
        # ROS2 subscription
        self.subscription = self.create_subscription(
            Twist,
            '/cmd_vel',
            self.cmd_vel_callback,
            10)
        
        # MAVLink connection
        self.connection = mavutil.mavlink_connection('/dev/ttyACM0', baud=921600)
        self.get_logger().info("Waiting for MAVLink heartbeat...")
        self.connection.wait_heartbeat()
        self.get_logger().info("Connected to flight controller")
        
        # Set mode to MANUAL
        self.set_manual_mode()
        
        # Arm the vehicle
        self.arm_vehicle()
        
        # Initialize last command values
        self.last_throttle = 0.0
        self.last_steering = 0.0
        
        # Create timer for continuous command sending - THIS IS CRUCIAL!
        self.timer = self.create_timer(0.05, self.send_continuous_commands)  # 20Hz
        
        self.get_logger().info("Rover control initialized with 20Hz continuous commands")

    def set_manual_mode(self):
        """Set the vehicle to MANUAL mode"""
        try:
            # Send mode change command
            self.connection.mav.command_long_send(
                self.connection.target_system,
                self.connection.target_component,
                mavutil.mavlink.MAV_CMD_DO_SET_MODE,
                0,  # confirmation
                mavutil.mavlink.MAV_MODE_FLAG_CUSTOM_MODE_ENABLED,
                0,  # MANUAL mode for rover
                0, 0, 0, 0, 0
            )
            
            # Wait for mode confirmation
            time.sleep(0.5)
            self.get_logger().info("Set mode to MANUAL")
            
        except Exception as e:
            self.get_logger().error(f"Failed to set MANUAL mode: {e}")

    def arm_vehicle(self):
        """Arm the vehicle"""
        try:
            self.connection.mav.command_long_send(
                self.connection.target_system,
                self.connection.target_component,
                mavutil.mavlink.MAV_CMD_COMPONENT_ARM_DISARM,
                0,  # confirmation
                1,  # arm
                0, 0, 0, 0, 0, 0
            )
            
            time.sleep(1)
            self.get_logger().info("Vehicle armed")
            
        except Exception as e:
            self.get_logger().error(f"Failed to arm vehicle: {e}")

    def cmd_vel_callback(self, msg):
        """Handle incoming Twist messages from /cmd_vel topic"""
        # Store the commands for continuous sending
        self.last_throttle = msg.linear.x
        self.last_steering = msg.angular.z
        
        self.get_logger().info(f"Received: throttle={self.last_throttle:.2f}, steering={self.last_steering:.2f}")

    def send_continuous_commands(self):
        """Send continuous manual_control commands at 20Hz - CRITICAL for ESC operation"""
        try:
            # Convert commands to PWM range - LIMITED THROTTLE for safety!
            # IMPORTANT: X = throttle, Y = steering (this mapping worked for steering!)
            throttle_scaled = int(1500 + (self.last_throttle * 100))  # Limited to 1400-1600 range
            steering_scaled = int(1500 + (self.last_steering * 500))   # Full steering range
            
            # Clamp to safe PWM ranges
            throttle_scaled = max(1400, min(1600, throttle_scaled))  # Max speed 1600
            steering_scaled = max(1000, min(2000, steering_scaled))
            
            # Send manual_control command with X/Y parameter mapping
            self.connection.mav.manual_control_send(
                self.connection.target_system,
                throttle_scaled,  # X parameter (throttle)
                steering_scaled,  # Y parameter (steering) 
                500,   # Z (not used)
                500,   # R (not used)
                0      # Buttons
            )
            
            # Debug output for significant commands
            if abs(self.last_throttle) > 0.1 or abs(self.last_steering) > 0.1:
                self.get_logger().info(f"Sent manual_control - throttle: {throttle_scaled}, steering: {steering_scaled}")
                
        except Exception as e:
            self.get_logger().error(f"Failed to send manual_control: {e}")

    def stop_rover(self):
        """Stop the rover by sending neutral commands"""
        try:
            # Send neutral manual_control commands
            self.connection.mav.manual_control_send(
                self.connection.target_system,
                1500,  # X (neutral throttle)
                1500,  # Y (neutral steering)
                500,   # Z
                500,   # R
                0      # Buttons
            )
            
            self.get_logger().info("Rover stopped - sent neutral manual_control")
            
        except Exception as e:
            self.get_logger().error(f"Failed to stop rover: {e}")

    def cleanup(self):
        """Cleanup when shutting down"""
        self.get_logger().info("Cleaning up...")
        self.stop_rover()
        time.sleep(0.5)

def main(args=None):
    rclpy.init(args=args)
    
    try:
        rover = RoverControl()
        rclpy.spin(rover)
    except KeyboardInterrupt:
        print("\nReceived Ctrl+C, shutting down...")
    except Exception as e:
        print(f"Error: {e}")
    finally:
        try:
            rover.cleanup()
        except:
            pass
        try:
            rclpy.shutdown()
        except:
            pass

if __name__ == '__main__':
    main()
